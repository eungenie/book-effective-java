> 요약 | 배열보다는 리스트를 사용하라

> 배열과 제네릭의 차이
1. 배열은 공변 : 제네릭은 불공변

- class Sub extends Super 이라면,
Sub[]은 Super[]의 하위 타입다.
  
- 서로 다른 타입 Type1, Type2가 있을 때, List<Type1>은 List<Type2>의 하위 타입도 상위 타입도 아니다.

Long용 저장소이기 때문에 String을 넣을 수 없는데, 배열은 런타임 때, 리스트는 컴파일 때 알아챌 수 있다.

~~~java
// 런타임 실패할 때 알게 된다.
Object[] objectArray = new Long[1];
objectArray[0] = "타입이 달라서 넣을 수 없다."; //ArrayStoreException을 던진다.
~~~

~~~java
// 컴파일부터 불가하다. (!)
List<Object> ol = new ArrayList<Long>(); //호환되지 않는 타입이다.
ol.add("타입이 달라서 넣을 수 없다.");
~~~

2. 배열은 실체화 : 제네릭은 런타임에 타입 정보가 소거

- 제네릭은 원소 타입을 컴파일 타임에만 검사하며, 런타임에는 알 수 조차 없다.

> 제네릭 배열은 생성할 수 없다 - 컴파일 불
> 
예시) 
~~~java
List<String>[] stringLists = new List<String>[1];   //(1)
List<Integer> intList = List.of(42);                //(2)
Object[] objects = stringLists;                     //(3)
objects[0] = intList;                               //(4)
String s = stringLists[0].get(0);                   //(5)
~~~

- 만약 (1)이 허용된다면,
- (2)는 원소가 하나인 List<Intger>를 생성한다.
- (3)은 (1)에서 생성한 List<String>의 배열을 Object 배열에 할당한다. 
  
"배열은 공변이므로 문제 없다."
- (4)는 (2)에서 생성한 List<Intger>의 인스턴스를 Object 배열의 첫 원소로 저장한다.

"제네릭은 소거 방식으로 문제 없다."

- 즉, 런타임에는 List<Integer> 인스턴스의 타입은 List가 되고, List<Integer>[] 인스턴스의 타입은 List[]가 된다.
- 따라서 (4)에서도 ArrayStoreException을 일으키지 않는다.

" 다만, List<String> 인스턴스만 담으려고 선언한 stringLists 배열에 List<Integer> 인스턴스가 저장돼 있다."
- (5)는 이 배열의 첫 리스트에서 첫 원소를 꺼내려고 한다.
- 컴파일러는 꺼낸 원소를 자동으로 String으로 형변환 하는데, 이 원소는 Integer이므로, 런타임에 ClassCastException이 발생한다.

"이를 방지하기 위해 제네릭 배열이 생성되지 않도록 (1)에서 컴파일 오류를 내야 한다."

> E, List<E>, List<String> - 실체화 불가 타입

- 실체화되지 않아서 런타임에는 컴파일타임보다 타입 정보를 적게 가지는 타입
- 소거 메커니즘 때문에 매개변수화 타입 가운데 실체화 될 수 있는 타입은 List<?>와 Map<?,?> 같은 비한정적 와일드카드 타입 뿐이다. (아이템26)
- 배열을 비한정적 와일드카드 타입으로 만들 수는 있지만, 유용하게 쓰일 일은 거의 없다.

> 배열로 형변환 시, 제네릭 배열 생성 오류나 비검사 형변환 경고가 뜨는 경우, 배열인 E[] 대신 컬렉션인 List<E>를 사용하면 해결된다.

- Chooser 클래스를 사용하려면 choose 메서드를 호출할 때마다, 반환된 Object를 원하는 타입으로 형변환해야 한다.
- 타입이 다른 원소가 들어 있다면 런타임에 형변환 오류가 날 것이다.
~~~java
public class Chooser {
    private final Object[] choiceArray;
    
    public Chooser(Collection choices) {
        this.choiceArray = choices.toArray();
    }
    
    // 이 메서드를 사용하는 곳에서는 매번 형변환이 필요하다.
    // 형변환 오류의 가능성이 있다.
    public Object choose() {
        Random rnd = ThreadLocalRandom.current();
        return choiceArray[rnd.nextInt(choiceArray.length)];
    }
}
~~~

- 제네릭으로 만든다.

~~~java
public class Chooser<T> {
    private final T[] choiceArray;

    public Chooser(Collection<T> choices) {
        // 오류 발생 incompatible types: java.lang.Object[] cannot be converted to T[]
        this.choiceArray = choices.toArray();
    }

    // choose 메소드는 동일하다.
}
~~~

- incompatible types 오류는 아래와 같이 코드를 변경하면 해결된다.

~~~java
// Object 배열을 T 배열로 형변환다 한.
this.choiceArray = (T[]) choices.toArray();
~~~

- Unchecked Cast 경고가 발생한다.
- 제네릭에서 원소의 타입 정보가 소거되어 런타임에는 무슨 타입인지 알 수 없다.
- 그래서 T가 무슨 타입인지 알 수 없으니 컴파일러는 이 형변환이 런타임에도 안전을 보장할 수 없다는 경고이다.

"비검사 형변환 경고를 제거하려면 배열 대신 리스트를 사용한다."

~~~java
class Chooser<T> {
    private final List<T> choiceList;

    public Chooser(Collection<T> choices) {
        this.choiceList = new ArrayList<>(choices);
    }

    public T choose() {
        Random rnd = ThreadLocalRandom.current();
        return choiceList.get(rnd.nextInt(choiceList.size()));
    }
}
~~~
- 런타임에 ClassCastException이 발생하지 않는다.

> 핵심정리 | 배열은 공변이고 실체화되는 반면, 제네릭은 불공변이고 타입 정보가 소거된다.
> 배열은 런타임에는 타입이 안전하지만 컴파일타임에는 그렇지 않고, 제네릭은 이 반대다.
> 
> 따라서 배열과 제네릭은 어우러지지 못하기 때문에, 함께 쓸 경우 가장 먼저 배열을 리스트로 대체하는 방법을 적용해보자.